<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Promises | Async Programming | Advanced Topics | JavaScript | Programming Bible</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300..800&family=Roboto:wght@300;400;500;700;900&display=swap"
    rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/src/css/style.css">
  <link rel="stylesheet" href="/src/css/highlightjs.css">
</head>

<body>
  <div class="page-container">
    <!-- Navigation -->
    <div class="nav-contained">
	<!-- Nav Menu -->
		<div id="nav-placeholder"></div>
	<!-- Sub Nav Menu -->
		<div id="subnav"></div>
</div>
    <!-- Sub Navigation -->
    

    <div class="content d-flex flex-row p-0">
      <!-- Side Navigation -->
      <div id="sidebar"></div>
      <!-- Main Content -->
      <div class="main-content d-flex flex-column m-0">
        <!-- Breadcrumb -->
        <nav class='crumb-parent m-0 d-flex' style="--bs-breadcrumb-divider: '>';" aria-label="breadcrumb">
          <ol class="breadcrumb open-sans">
            <div class="breadcrumb-item crumbs" id="crumbs"></div>
            <li class="breadcrumb-item active" aria-current="page">Promises</a></li>
          </ol>
        </nav>

        <!-- Content Start -->
        <div class="entry-content">
          <h1 class="primary-color-dark mb-4 anchor" id="top">Promises</h1>
          <div class="inner-int-gap">
            <div>Imagine you're playing an online multiplayer game, and you send a message to your friend asking if
              they're ready to team up for a mission. While waiting for their response, you don't just sit there staring
              at the screen, right? Instead, you might go check your inventory, upgrade your gear, or do some other
              task. This way, you're making the most of your time.</div>

            <div><strong class="primary-color-dark">Promises</strong> in JavaScript work similarly. They allow your code
              to handle tasks that might take some time (like fetching data from a server) without freezing up and doing
              nothing else. Instead, your code can continue running and come back to deal with the task once it's
              finished.</div>
            <div class="anchor mt-4" id="what-is-a-promise">
              <h4>What is a Promise?</h4>
              <div>A Promise is an object that represents the eventual completion (or failure) of an asynchronous
                operation and its resulting value. Think of it as a placeholder for a value that will be available
                later. <br><br>
                A Promise can be in one of three states:</div>
              <div class="mt-3">
                <ul>
                  <li><strong>Pending:</strong> The initial state, neither fulfilled nor rejected.</li>
                  <li><strong>Fulfilled:</strong> The operation completed successfully.</li>
                  <li><strong>Rejected:</strong> The operation failed.</li>
                </ul>
              </div>
            </div>
            <div>
              When a promise is initially created, it is in the <strong>pending</strong> state. This state indicates
              that the asynchronous operation is still in progress and hasn't yet resolved to a value (fulfilled) or
              encountered an error (rejected). While pending there wouldn't be any result or error at this point and the
              underlying operation is still in progress.
            </div>
            <div>
              When the asynchronous operation completes successfully, the promise transitions to the
              <strong>fulfilled</strong> state. This means the operation was successful, and the promise now holds a
              resolved value. It would have a value that represents the successful completion of the operation, and you
              can use the <span class="inject"><a
                  href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/then.html"
                  target="_blank">'.then'</a></span> function to access the resolved value.
            </div>
            <div>
              If the asynchronous operation encounters an error or fails to complete successfully, the promise
              transitions to the <strong>rejected</strong> state. This means the operation failed, and the promise now
              holds an error reason. It would have a value equal to the reason why the operation failed and you can
              utilize the <span class="inject"><a
                  href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/catch.html"
                  target="_blank">'.catch'</a></span> function to handle the error.
            </div>
            <div class="mt-3 d-flex flex-column">Here you can see a basic flowchart visualizing the states of a promise.
              <a href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/promise-flowchart.png"
                target="_blank"><img
                  src="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/promise-flowchart.png"
                  alt="" class="mt-3"></a>
            </div>
          </div>

          <!-- Syntax -->
          <div class="section-entry" id="syntax">
            <div class="section-title">
              <h3 class="primary-color-dark">Syntax</h3>
              <div class="section-card d-flex flex-column">
                <div class="my-3">The basic syntax for creating a Promise involves the new Promise constructor. Inside
                  this constructor, you provide a function (often called the executor function) that takes two
                  parameters: resolve and reject. These parameters are themselves functions used to determine the
                  outcome of the Promise. <br><br>
                  Here’s the basic structure:</div>
                <pre><code class="language-javascript">let myPromise = new Promise((resolve, reject) => {

  // Perform some asynchronous task

  if (/* task is successful */) {
      resolve('Success!');
  } else {
      reject('Error!');
  }
});</code></pre>
                <div class="inner-int-gap">
                  <div>
                    <h5 class="h-break">Breaking Down The Syntax</h5>
                    <h6>1. Promise Constructor</h6>
                    <pre><code class="language-javascript mt-2">new Promise((resolve, reject) => { ... });</code></pre>
                    <p>This initializes a new Promise object. The executor function inside the Promise constructor is
                      where you perform the asynchronous task.</p>
                  </div>
                  <div>
                    <h6>2. Executor Function</h6>
                    <pre><code class="language-javascript mt-2">(resolve, reject) => { ... }</code></pre>
                    <p>
                      This function has two parameters:
                    <ul>
                      <li><span class="inject">'resolve'</span>: Call this function when the asynchronous task completes
                        successfully. It passes the result of the task.</li>
                      <li><span class="inject">'reject'</span>: Call this function when the task fails. It passes the
                        error or reason for failure.</li>
                    </ul>
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div> <!-- End of Syntax Entry -->

          <!-- Example Code -->
          <div class="section-title" id="example">
            <div class="section-card d-flex flex-column">
              <div class="marg-entry">

                <h3 class="primary-color-dark">Example Code</h3>
                <div>
                  <div class="my-3">Let’s look at a more detailed example:</div>
                  <pre><code class="language-javascript">let fetchData = new Promise((resolve, reject) => {

  let dataFetched = true; // Simulating data fetch

  if (dataFetched) {
    resolve('Data fetched successfully!');
  } else {
    reject('Failed to fetch data.');
  }
});</code></pre>
                  <div class="inner-int-gap">

                    <div class="mt-3">In this example:
                      <ul class="my-2">
                        <li>We created a <strong>Promise</strong> named <span class="inject">'fetchData;'</span>.</li>
                        <li>Inside the executor function, we simulate data fetching with a boolean <span
                            class="inject">'dataFetched;'</span>.</li>
                        <li>If <span class="inject">'dataFetched'</span> is <span class="inject">'true'</span>, we call
                          <span class="inject">'resolve('Data fetched successfully!')'</span> indicating a success.
                        </li>
                        <li>If <span class="inject">'dataFetched'</span> is <span class="inject">'false'</span>, we call
                          <span class="inject">'reject('Failed to fetch data.')'</span> indicating a failure.
                        </li>
                      </ul>
                    </div>

                  </div>
                </div>
              </div>
            </div>
          </div><!-- End of Entry -->

          <!-- Handling Promises -->
          <div class="section-entry" id="handling-promises">
            <div class="section-title">
              <h3 class="primary-color-dark">Handling Promises</h3>
              <div class="section-card d-flex flex-column inner-int-gap mt-3">
                <div>To handle the result or error of a Promise, you use the <span class="inject"><a
                      href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/then.html"
                      target="_blank">'.then'</a></span>, <span class="inject"><a
                      href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/catch.html"
                      target="_blank">'.catch'</a></span>, and <span class="inject"><a
                      href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/finally.html">'.finally'</a></span>
                  methods. You can click each link to dive deeper into each, but to get an idea, here's a quick
                  breakdown of what they do.</div>


                <div>
                  <h5 class="mt-4">.then</h5>
                  <p>Used to handle the resolved value.</p>
                  <pre><code class="language-javascript">fetchData.then((message) => {
  console.log(message); // Logs: 'Data fetched successfully!'
});</code></pre>
                </div>


                <div>
                  <h5 class="mt-4">.catch</h5>
                  <p>Used to handle rejection.</p>
                  <pre><code class="language-javascript">fetchData.catch((error) => {
  console.log(error); // Logs: 'Failed to fetch data.'
});</code></pre>
                </div>


                <div>
                  <h5 class="mt-4">.finally</h5>
                  <p>Executed regardless of the outcome.</p>
                  <pre><code class="language-javascript">fetchData.finally(() => {
  console.log('Fetch attempt finished.');
});</code></pre>
                </div>


                <div>
                  With knowledge of these, let's take a look at a real world example as if you're fetching data from an
                  API.
                  <pre><code class="language-javascript mt-3">fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
      console.log('Data received:', data);
  })
  .catch(error => {
      console.error('Error fetching data:', error);
  })
  .finally(() => {
      console.log('Fetch attempt finished.');
  });</code></pre>
                </div>


              </div>
            </div>
          </div> <!-- End of Entry -->

          <!-- Chaining Promises -->
          <div class="section-title" id="chaining-promises">
            <div class="section-card d-flex flex-column">
              <div class="marg-entry">
                <div class="inner-int-gap">
                  <h3 class="primary-color-dark">Chaining Promises</h3>
                  <div class="inner-int-gap">
                    <div>Promises can be chained to perform a sequence of asynchronous operations. Each <span
                        class="inject">'.then'</span> returns a new promise, allowing you to chain multiple <span
                        class="inject">'.then'</span> methods together</div>
                    <pre><code class="language-javascript">fetchGameData()
  .then((data) => processGameData(data))
  .then((processedData) => displayGameData(processedData))
  .catch((error) => console.error('Error:', error));</code></pre>
                  </div>
                </div>
              </div>
            </div>
          </div> <!-- End of Entry -->

          <!-- Why Use Promises -->
          <div class="section-entry" id="why-use-promises">
            <div class="section-title">
              <div class="section-card d-flex flex-column">
                <h3 class="primary-color-dark">Why Use Promises?</h3>
                <div>Using async functions and promises in JavaScript is essential for managing
                  asynchronous operations efficiently. Here’s a detailed explanation of why they are
                  useful.</div>
                <div class="int-gap">
                  <div class="anchor inner-int-gap" id="improved-readability">
                    <div>
                      <h4>Improved Code Readability</h4>
                    </div>
                    <div><strong>Sequential Logic:</strong> Promises enable you to write
                      asynchronous code that appears more sequential and logical. This is achieved
                      through chaining <span class="inject"><a
                          href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/then.html"
                          target="_blank">'.then'</a></span> methods, which makes the flow of
                      data and operations clearer.</div>
                    <div>
                      <pre><code class="language-javascript">// Example 
            async function fetchData() {
                try {
                    let response = await fetch('https://api.example.com/game_data');
                    let data = await response.json();
                    console.log(data);
                } catch (error) {
                    console.error('Error:', error);
                }
            }</code></pre>
                    </div>
                    <div>Here, the code reads like a series of steps, making it easier to follow.
                    </div>
                  </div>
                  <div class="anchor inner-int-gap" id="better-error-handling">
                    <div>
                      <h4>Better Error Handling</h4>
                    </div>
                    <div><strong>Try/Catch Blocks:</strong> With <span class="inject"><a
                          href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/async-await.html"
                          target="_blank">'async/await'</a></span>, you can use <span class="inject">'try'</span> and
                      <span class="inject">'catch'</span>
                      blocks to handle errors, similar to synchronous code. This consolidates
                      error handling into a single place, making it more organized and easier
                      to
                      manage.
                    </div>
                    <div>
                      <pre><code class="language-javascript">// Example
            function fetchData()
                .then(response => processResponse(response))
                .then(data => displayData(data))
                .catch(error => handleError(error));</code></pre>
                    </div>
                    <div>In this example, all potential errors are handled within the catch
                      block,
                      providing a clear structure for error management.</div>
                  </div>
                  <div class="anchor inner-int-gap" id="avoiding-callback">
                    <div>
                      <h4>Avoiding Callback Hell</h4>
                    </div>
                    <div><strong>Flat and Manageable Structure:</strong> Promises help avoid deeply
                      nested callbacks, commonly known as "callback hell" or "pyramid of doom,"
                      which can make code hard to read and maintain.</div>
                    <pre><code class="language-javascript">// Callback
            doSomething((result1) => {
                doSomethingElse(result1, (result2) => {
                    doAnotherThing(result2, (result3) => {
              console.log(result3);
                    });
                });
            });
            
            // Promises 
            doSomething()
              .then(result1 => doSomethingElse(result1))
              .then(result2 => doAnotherThing(result2))
              .then(result3 => console.log(result3))
              .catch(error => console.error(error));</code></pre>
                    <div>Promises flatten the structure, making it easier to follow the flow of
                      operations.</div>
                  </div>
                  <div class="anchor inner-int-gap" id="concurrency-management">
                    <div>
                      <h4>Concurrency Management</h4>
                    </div>
                    <div><strong>Handling Multiple Asynchronous Operations:</strong> Promises
                      provide methods like <span class="inject"><a
                          href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/all.html"
                          target="_blank">'Promise.all'</a></span>, <span class="inject"><a
                          href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/race.html"
                          target="_blank">'Promise.race'</a></span>, and <span class="inject"><a
                          href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/allSettled.html"
                          target="_blank">'Promise.allSettled'</a></span> to manage multiple
                      asynchronous operations concurrently.</div>
                    <pre><code class="language-javascript">// Example using Promise.all
            let promise1 = fetch('https://api.example.com/data1').then(res => res.json());
            let promise2 = fetch('https://api.example.com/data2').then(res => res.json());
            
            Promise.all([promise1, promise2])
             .then(results => {
               console.log('Data1:', results[0]);
               console.log('Data2:', results[1]);
             })
             .catch(error => console.error('An error occurred:', error));</code></pre>
                    <div><span class="inject">'Promise.all'</span> waits for all promises to resolve
                      and then proceeds, making it useful for tasks that can run in parallel.
                    </div>
                  </div>
                  <div class="anchor inner-int-gap" id="non-blocking-operations">
                    <div>
                      <h4>Non-Blocking Operations</h4>
                    </div>
                    <div><strong>Asynchronous Execution:</strong> Promises allow asynchronous
                      operations to run without blocking the main thread. This is crucial for
                      maintaining a responsive user interface, especially in web applications.
                    </div>
                    <pre><code class="language-javascript">// Example
            fetch('https://api.example.com/data')
              .then(response => response.json())
              .then(data => {
                console.log(data);
                // Continue with other tasks
              })
              .catch(error => console.error('An error occurred:', error));</code></pre>
                    <div>While the data is being fetched, other operations can continue to execute.
                    </div>
                  </div>
                  <div class="anchor inner-int-gap" id="composability">
                    <div>
                      <h4>Composability</h4>
                    </div>
                    <div><strong>Combining Promises:</strong> Promises can be easily composed and
                      chained to create complex workflows. This composability makes it easier to
                      build sophisticated asynchronous logic.
                    </div>
                    <pre><code class="language-javascript">// Example
            function fetchDataAndProcess() {
                return fetch('https://api.example.com/data')
                  .then(response => response.json())
                  .then(data => processData(data));
            }
              
            fetchDataAndProcess()
              .then(processedData => console.log('Processed Data:', processedData))
              .catch(error => console.error('An error occurred:', error));</code></pre>
                    <div>By breaking down tasks into smaller promise-returning functions, you can
                      compose them together for more complex operations.
                    </div>
                  </div>
                  <div class="anchor inner-int-gap" id="integration-with-modern-javascript">
                    <div>
                      <h4>Integration with Modern JavaScript</h4>
                    </div>
                    <div><strong>Compatibility with Async/Await:</strong> Promises work seamlessly
                      with <span class="inject"><a
                          href="/src/pages/languages/javascript/advanced-topics/asynchronous-programming/async-await.html"
                          target="_blank">'async/await'</a></span>, further simplifying
                      asynchronous code. The combination provides the benefits of promises with
                      the simplicity of synchronous code.
                    </div>
                    <pre><code class="language-javascript">// Example
            async function fetchDataAndDisplay() {
                try {
                  let response = await fetch('https://api.example.com/data');
                  let data = await response.json();
                  console.log(data);
                } catch (error) {
                  console.error('An error occurred:', error);
                }
              }
              
            fetchDataAndDisplay();</code></pre>
                    <div>Using <span class="inject">'async/await'</span> with promises enhances code
                      readability and maintainability.
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div> <!-- End of Entry -->

          <!-- Additional Info -->
          <div class="section-title" id="tips">
            <div class="section-card d-flex flex-column">
              <div class="marg-entry">
                <div class="inner-int-gap">
                  <h3 class="primary-color-dark">Tips</h3>
                  <div class="d-flex flex-column gap-2">
                    <div>
                      <strong>Always handle errors: </strong> Use <span class="inject">'.catch'</span> to manage any errors that occur. 
                    </div>
                    <div>
                      <strong>Keep it readable: </strong> Chain promises logically to keep your code clean and understandable. 
                    </div>
                    <div>
                      <strong>Use async/await: </strong> Once you're comfortable with promises, explore <span class="inject">'async'</span> and <span class="inject">'await'</span> for a more readable way to handle asynchronous code. 
                    </div>
                  </div>
                </div>

                <div class="inner-int-gap" id="common-mistakes">
                  <h3 class="primary-color-dark mt-5">Common Mistakes</h3>
                  <div class="d-flex flex-column gap-2">
                    <div>
                      <strong>Forgetting to return a promise: </strong> When chaining, always return the next promise inside a <span class="inject">'.then'</span>. 
                    </div>
                    <div>
                      <strong>Not handling errors: </strong> Failing to include a <span class="inject">'.catch'</span> can lead to unhandled rejections. 
                    </div>
                    <div>
                      <strong>Misunderstanding promise states: </strong> Remember that a promise can only be settled once (either resolved or rejected), and this state is final.
                  </div>
                </div>
              </div>
            </div>
            </div>
          </div> <!-- End of Entry -->

          <!-- Use Cases -->
          <div class="section-entry" id="use-cases">
            <div class="section-title">
              <h3 class="primary-color-dark">Use Cases</h3>
              <div class="section-card d-flex flex-column inner-int-gap">
                <div class="mt-3">Now that we have a firm understanding of what a Promise does, let's see how it can
                  be utilized.</div>

                <div>
                  <h4 class="mt-3" id="loading-game-resources">Scenario: Loading Game Resources
                  </h4>
                </div>

                <div>Let's consider a realistic scenario in video game development where promises are
                  used to handle asynchronous tasks. Imagine we're developing an online multiplayer
                  game where players can join matches, and we need to load various resources (e.g.,
                  player data, game settings, assets) before starting the game. Using promises can
                  help us manage these asynchronous operations efficiently.</div>
                <div>In this scenario, we'll need to do three things.
                  <ol>
                    <li>1. <strong>Fetch Player Data:</strong> Retrieve player data from a server.
                    </li>
                    <li>2. <strong>Load Game Settings:</strong> Fetch game settings from a
                      configuration file.</li>
                    <li>3. <strong>Load Game Assets:</strong> Load required assets.</li>
                  </ol>
                </div>
                <div>
                  We'll use promises to handle these tasks and ensure they are completed before
                  starting the game. We will then break down what each function does separately.
                </div>


                <pre><code class="language-javascript">// Function to fetch player data from the server
function fetchPlayerData(playerId) {
  return fetch(`https://api.example.com/players/${playerId}`)
    .then(response => {
      if (!response.ok) {
        throw new Error('Failed to fetch player data');
      }
      return response.json();
    });
}

// Function to load game settings from a configuration file
function loadGameSettings() {
  return fetch('https://api.example.com/game-settings')
    .then(response => {
      if (!response.ok) {
        throw new Error('Failed to load game settings');
      }
      return response.json();
    });
}

// Function to load a game asset (e.g., image)
function loadAsset(assetUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(assetUrl);
    img.onerror = () => reject(new Error('Failed to load asset: ' + assetUrl));
    img.src = assetUrl;
  });
}

// Function to load multiple game assets
function loadGameAssets(assetUrls) {
  return Promise.all(assetUrls.map(url => loadAsset(url)));
}

// Main function to start the game
async function startGame(playerId, assetUrls) {
  try {
    // Fetch player data
    const playerData = await fetchPlayerData(playerId);
    console.log('Player Data:', playerData);

    // Load game settings
    const gameSettings = await loadGameSettings();
    console.log('Game Settings:', gameSettings);

    // Load game assets
    const loadedAssets = await loadGameAssets(assetUrls);
    console.log('Loaded Assets:', loadedAssets);

    // Start the game with loaded resources
    console.log('Starting game with loaded resources...');
    // Initialize and start the game here
  } catch (error) {
    console.error('Error:', error);
  }
}

// Example usage
const playerId = '12345';
const assetUrls = [
  'https://example.com/assets/character.png',
  'https://example.com/assets/background.png',
  'https://example.com/assets/soundtrack.mp3',
];

startGame(playerId, assetUrls);</code></pre>


                <div class="mt-4">
                  <h5>Fetch Player Data</h5>
                </div>
                <pre><code class="language-javascript">function fetchPlayerData(playerId) {
  return fetch(`https://api.example.com/players/${playerId}`)
    .then(response => {
      if (!response.ok) {
        throw new Error('Failed to fetch player data');
      }
      return response.json();
    });
}</code></pre>
                <div>The <span class="inject">'fetchPlayerData'</span> function fetches player data from
                  the server using the Fetch API. It then returns a promise that resolves to the
                  player data in JSON format or rejects if the request fails.</div>


                <div class="mt-4">
                  <h5>Loading Game Settings</h5>
                </div>
                <pre><code class="language-javascript">function loadGameSettings() {
  return fetch('https://api.example.com/game-settings')
    .then(response => {
      if (!response.ok) {
        throw new Error('Failed to load game settings');
      }
      return response.json();
    });
}</code></pre>
                <div>The <span class="inject">'loadGameSettings'</span> function fetches game settings
                  from a remote configuration file. It then returns a promise that resolves to the
                  game settings in JSON format or rejects if the request fails.</div>


                <div class="mt-4">
                  <h5>Loading Game Assets</h5>
                </div>
                <pre><code class="language-javascript">function loadAsset(assetUrl) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(assetUrl);
    img.onerror = () => reject(new Error('Failed to load asset: ' + assetUrl));
    img.src = assetUrl;
  });
}

function loadGameAssets(assetUrls) {
    return Promise.all(assetUrls.map(url => loadAsset(url)));
}</code></pre>
                <div>The <span class="inject">'loadAsset'</span> function creates a promise that
                  resolves when an asset (e.g., image) is successfully loaded and rejects if it fails
                  to load. The <span class="inject">'loadGameAssets'</span> function uses <span
                    class="inject">'Promise.all'</span> to load multiple assets concurrently,
                  returning a promise that resolves when all assets are loaded.</div>


                <div class="mt-4">
                  <h5>Starting the Game</h5>
                </div>
                <pre><code class="language-javascript">async function startGame(playerId, assetUrls) {
  try {
    // Fetch player data
    const playerData = await fetchPlayerData(playerId);
    console.log('Player Data:', playerData);

    // Load game settings
    const gameSettings = await loadGameSettings();
    console.log('Game Settings:', gameSettings);

    // Load game assets
    const loadedAssets = await loadGameAssets(assetUrls);
    console.log('Loaded Assets:', loadedAssets);

    // Start the game with loaded resources
    console.log('Starting game with loaded resources...');
    // Initialize and start the game here
  } catch (error) {
    console.error('Error:', error);
  }
}</code></pre>
                <div>The <span class="inject">'startGame'</span> function is an <span class="inject">'async'</span>
                  function that uses <span class="inject">'await'</span> to handle the asynchronous tasks in sequence.
                  It
                  fetches player data, loads game settings, and loads game assets. If all tasks are
                  successful, the game starts with the loaded resources. If any task fails, an error
                  is caught and logged.</div>


                <div>
                  <h4 class="mt-4 anchor" id="registration-and-login">Scenario: User Registration and
                    Login</h4>
                </div>
                <div>Let's consider another scenario in terms of Web Development. We have created a
                  website and need to handle user registration and logging in.</div>
                <div>In this scenario, we will.
                  <ol>
                    <li>1. <strong>Fetch User Data:</strong>Validate the user's registration
                      details.</li>
                    <li>2. <strong>Save User Data:</strong> Save the user data to the database.</li>
                    <li>3. <strong>Provide Access:</strong> Log the user in and generate a session
                      token.</li>
                  </ol>
                </div>

                <div>
                  <pre><code class="language-javascript">const usersDatabase = []; // Simulating a database

const validateRegistration = (user) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (user.username && user.password) {
        console.log(`User details validated.`);
        resolve(user);
      } else {
        reject(`Validation failed: Username and password are required.`);
      }
    }, generateRandomDelay());
  });
};

const saveUserToDatabase = (user) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const userExists = usersDatabase.some(existingUser => existingUser.username === user.username);
      if (!userExists) {
        usersDatabase.push(user);
        console.log(`User saved to database.`);
        resolve(user);
      } else {
        reject(`User registration failed: Username already exists.`);
      }
    }, generateRandomDelay());
  });
};

const loginUser = (user) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const loggedInUser = usersDatabase.find(existingUser => 
      existingUser.username === user.username && existingUser.password === user.password);

      if (loggedInUser) {
        const sessionToken = generateSessionToken();
        console.log(`User logged in. Session token: ${sessionToken}`);
        resolve(`User ${user.username} logged in successfully. Session token: ${sessionToken}`);
      } else {
        reject(`Login failed: Invalid username or password.`);
      }
    }, generateRandomDelay());
  });
};

function generateSessionToken() {
  return Math.floor(Math.random() * 1000000);
}

function generateRandomDelay() {
  return Math.floor(Math.random() * 2000);
}

const user = {
  username: 'newUser',
  password: 'password123'
};

validateRegistration(user)
  .then((validatedUser) => {
    return saveUserToDatabase(validatedUser);
  })
  .then((savedUser) => {
    return loginUser(savedUser);
  })
  .then((successMessage) => {
    console.log(successMessage);
  })
  .catch((errorMessage) => {
    console.log(errorMessage);
  });</code></pre>


                  <div class="mt-4">
                    <h5>Validate Registration</h5>
                  </div>
                  <pre><code class="language-javascript">const validateRegistration = (user) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (user.username && user.password) {
        console.log(`User details validated.`);
        resolve(user);
      } else {
        reject(`Validation failed: Username and password are required.`);
      }
    }, generateRandomDelay());
  });
};</code></pre>
                  <div>The <span class="inject">'validateRegistration'</span> function checks if the user's registration
                    details (username and password) are provided. It returns a promise that resolves if the details are
                    valid and rejects if they are not.</div>


                  <div class="mt-4">
                    <h5>Save User to Database</h5>
                  </div>
                  <pre><code class="language-javascript">const saveUserToDatabase = (user) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const userExists = usersDatabase.some(existingUser => existingUser.username === user.username);
      if (!userExists) {
        usersDatabase.push(user);
        console.log(`User saved to database.`);
        resolve(user);
      } else {
        reject(`User registration failed: Username already exists.`);
      }
    }, generateRandomDelay());
  });
};</code></pre>
                  <div>The <span class="inject">'saveUserToDatabase'</span> function simulates saving the user to a
                    database by pushing the user object into an array. It returns a promise that resolves if the user is
                    saved successfully and rejects if the username already exists in the database.</div>


                  <div class="mt-4">
                    <h5>Login User</h5>
                  </div>
                  <pre><code class="language-javascript">const loginUser = (user) => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const loggedInUser = usersDatabase.find(existingUser => 
      existingUser.username === user.username && existingUser.password === user.password);

      if (loggedInUser) {
        const sessionToken = generateSessionToken();
        console.log(`User logged in. Session token: ${sessionToken}`);
        resolve(`User ${user.username} logged in successfully. Session token: ${sessionToken}`);
      } else {
        reject(`Login failed: Invalid username or password.`);
      }
    }, generateRandomDelay());
  });
};</code></pre>
                  <div>The <span class="inject">'loginUser'</span> function simulates logging the user in by checking if
                    the username and password match an entry in the database. It returns a promise that resolves with a
                    session token if the login is successful and rejects if the login fails.</div>


                  <div class="mt-4">
                    <h5>Chaining Promises</h5>
                  </div>
                  <pre><code class="language-javascript">validateRegistration(user)
    .then((validatedUser) => {
      return saveUserToDatabase(validatedUser);
    })
    .then((savedUser) => {
      return loginUser(savedUser);
    })
    .then((successMessage) => {
      console.log(successMessage);
    })
    .catch((errorMessage) => {
      console.log(errorMessage);
    });</code></pre>
                  <div>With this, the promises are ran in order and can be chained together. Once one promise is
                    resolved, the next will then run with the returned resolution.</div>
                </div>
              </div>
            </div>
          </div> <!-- End of Use Cases Entry -->

        </div> <!-- END OF CONTENT-->

        <!-- Internal Navigation -->
        <div class="internal-nav" id="internalNav">
          <h6>Jump To Section</h6>
          <hr class="internal-hr">
          <div class="internal-links">
            <ul>
              <li><a href="#top">Overview</a></li>
              <li><a href="#what-is-a-promise">What Is a Promise?</a></li>
              <li><a href="#syntax">Syntax</a></li>
              <li><a href="#example">Example Code</a></li>
              <li><a href="#handling-promises">Handling Promises</a></li>
              <li><a href="#chaining-promises">Chaining Promises</a></li>
              <li><a href="#why-use-promises">Why Use Promises?</a></li>
              <ul class="inner-ul">
                <li class="inner-li"><a href="#improved-readability">Improved Code Readability</a></li>
                <li class="inner-li"><a href="#better-error-handling">Better Error Handling</a></li>
                <li class="inner-li"><a href="#avoiding-callback">Avoiding Callback Hell</a></li>
                <li class="inner-li"><a href="#concurrency-management">Concurrency Management</a></li>
                <li class="inner-li"><a href="#non-blocking-operations">Non-Blocking Operations</a></li>
                <li class="inner-li"><a href="#composability">Composability</a></li>
                <li class="inner-li"><a href="#integration-with-modern-javascript">Integration with
                    Modern JavaScript</a></li>
              </ul>
              <li><a href="#tips">Tips</a></li>
              <li><a href="#common-mistakes">Common Mistakes</a></li>
              <li><a href="#use-cases">Use Cases</a></li>
              <ul class="inner-ul">
                <li class="inner-li"><a href="#loading-game-resources">Loading Game Resources</a></li>
                <li class="inner-li"><a href="#registration-and-login">User Registration and Login</a>
                </li>
              </ul>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
  <script src="/src/script.js"></script>

  <script script type='module'>
    import { navInsert, setActive } from '/src/utilities.js';
    const path = '/src/pages/languages/javascript/advanced-topics/asynchronous-programming/promises/sidebar.html';

    // Sub Nav
    navInsert('/src/pages/languages/js-subnav.html', 'subnav');
    // Sidebar
    navInsert(path, 'sidebar');
    //Crumbs
    navInsert('/src/pages/languages/javascript/advanced-topics/asynchronous-programming/crumbs.html', 'crumbs');
    // Set Active Link in Sidebar
    setActive(path, 'sidebar', 'promises');
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>hljs.highlightAll();</script>
</body>

</html>